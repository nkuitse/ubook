#!/usr/bin/perl

use strict;
use warnings;

use Getopt::Std;

sub run;
sub fatal;
sub usage;

my %opt = (
    'd' => $ENV{'UBOOK'} ||= '/var/local/ubook',
    'p' => '/bin:/usr/bin',
    'P' => 0,  # Ask for password?
    'M' => 0,  # Don't create home dir?
    'n' => 0,  # Dry run?
    'v' => 0,  # Verbose?
    'q' => 0,  # Only check?
);

getopts(':d:p:PMnvq', \%opt) or usage;
usage if @ARGV != 1;
my ($dir, $path, $askpass, $nohome, $dryrun, $verbose, $check) = delete @opt{qw(d p P M n v q)};

my $login = shift;
usage 'LOGIN must be a login name, not a UID' if $login =~ /^-?\d+$/;
usage 'LOGIN must not begin with "-"'         if $login =~ /^-/;

my @user = getpwnam($login);
fatal "User $login already exists" if @user && !$dryrun;

my %user = user($login);
my ($uid, $gid, $comment, $home, $shell) = @user{qw(uid gid comment home shell)};

print STDERR "Dry run -- no changes will be made\n";
my @group = getgrgid($gid);
if (!@group) {
    # Create the group first
    my %group = group($gid);
    my @groupadd = (
        '/usr/sbin/groupadd',
        '-g' => $gid,
        $login
    );
    run 'create group' => @groupadd;
}

my @useradd = (
    '/usr/sbin/useradd',
    '-u' => $uid,
    '-g' => $gid,
    '-d' => $home,
    '-c' => $comment,
    '-s' => $shell,
);
push @useradd, '-m' if !$nohome;
push @useradd, $login;
run 'create user' => @useradd;

if ($askpass) {
    run 'set password' => 'passwd', $login;
}

# --- Functions

sub run {
    my $task = shift;
    if ($dryrun) {
        my $cmd = join(' ', map { quotem($_) } @_);
        print STDERR "$task:\n  $cmd\n\n";
        return;
    }
    my $err = system @_;
    fatal -1, "$task failed: $!" if $err == -1;
    fatal $err >> 8, "$task failed: $!" if $err;
}

sub user {
    my ($login) = @_;
    fatal "login $login has not been defined" if ! -e "$dir/user/$login/user.rx";
    open my $fh, '<', "$dir/user/$login/user.rx" or fatal "can't open recipe for user $login: $!";
    while (<$fh>) {
        next if /^\s*(?:#.*)?$/;  # Skip blank lines and comments
        chomp;
        /^\s*(\S+)\s+(.*)$/ or die "Bad line in $dir/user/$login/user.rx: $_";
        $user{$1} = $2;
    }
    close $fh;
    fatal "huh?" if $user{'login'} ne $login;
    my ($uid, $gid, $comment, $home) =
        map { defined $user{$_} ? $user{$_} : fatal "user recipe lacks $_" }
            qw(uid gid comment home);
    fatal "I won't touch root or wheel!"
        if !$uid || !$gid;
    $user{'shell'} = find_shell($user{'shell'} || '/')
        || fatal "no shell found";
    return %user;
}

sub group {
    my ($group) = @_;
    fatal "group $group has not been defined" if ! -e "$dir/group/$group/group.rx";
    open my $fh, '<', "$dir/group/$group/group.rx" or fatal "can't open recipe for group $group $!";
    my %group;
    while (<$fh>) {
        next if /^\s*(?:#.*)?$/;  # Skip blank lines and comments
        chomp;
        my ($key, $val) = split /\s+/, $_, 2;
        $group{$key} = $val;
    }
    close $fh;
    fatal "huh?" if $group{'gid'} ne $group;
    fatal "huh???" if !defined $group{'gid'};
    fatal "I won't touch root or wheel!"
        if !$gid;
    return %group;
}

sub find_shell {
    my ($shell) = @_;
    my @path = split /:/, $path;
    foreach my $s (split /\s+/, $shell) {
        if ($s =~ m{^/}) {
            return $s if -f $s && -x _;
        }
        elsif ($s =~ m{/}) {
            fatal "invalid shell: $shell";
        }
        else {
            foreach (@path) {
                return "$_/$s" if -f "$_/$s" && -x _;
            }
        }
    }
    return;
}

sub fatal {
    my $err = @_ > 1 ? shift : 2;
    print STDERR 'umake: ', shift, "\n";
    exit $err;
}

sub usage {
    print STDERR $_, "\n" for @_;
    print STDERR "usage: umake [-d DIR] [-p PATH] [-PMnvq] LOGIN\n";
    exit 1;
}

sub quotem {
    my ($str) = @_;
    return $str if $str =~ m{^[-+:/\w]+$};
    return qq{'$str'} if $str !~ /'/;
    $str =~ s/(\\|\$|")/\\$1/g;
    return qq{"$str"};
}
